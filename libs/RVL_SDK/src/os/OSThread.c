#include <decomp.h>

#include <revolution/os.h>
#include <private/os.h>

#include <revolution/base/PPCArch.h>

/* Macros for dequeueing and enqueueing thread */

#define ENQUEUE_THREAD(thread, queue, link) { \
    OSThread* __prev = (queue)->tail;         \
    if (__prev == NULL) {                     \
        (queue)->head = (thread);             \
    }                                         \
    else {                                    \
        __prev->link.next = (thread);         \
    }                                         \
    (thread)->link.prev = __prev;             \
    (thread)->link.next = NULL;               \
    (queue)->tail = (thread);                 \
}

#define DEQUEUE_THREAD(thread, queue, link) {   \
    OSThread* __next = (thread)->link.next;     \
    OSThread* __prev = (thread)->link.prev;     \
    if (__next == NULL) {                       \
        (queue)->tail = __prev;                 \
    }                                           \
    else {                                      \
        __next->link.prev = __prev;             \
    }                                           \
    if (__prev == NULL) {                       \
        (queue)->head = __next;                 \
    }                                           \
    else {                                      \
        __prev->link.next = __next;             \
    }                                           \
}

#define ENQUEUE_THREAD_PRIO(thread, queue, link) { \
    OSThread* __prev;                              \
    OSThread* __next;                              \
    for(__next = (queue)->head; __next             \
      && (__next->priority <= (thread)->priority); \
            __next = __next->link.next) ;          \
                                                   \
    if (__next == NULL) {                          \
        ENQUEUE_THREAD(thread, queue, link);       \
    }                                              \
    else {                                         \
        (thread)->link.next = __next;              \
        __prev = __next->link.prev;                \
        __next->link.prev = (thread);              \
        (thread)->link.prev = __prev;              \
        if (__prev == NULL) {                      \
            (queue)->head = (thread);              \
        }                                          \
        else {                                     \
            __prev->link.next = (thread);          \
        }                                          \
    }                                              \
}

#define DEQUEUE_HEAD(thread, queue, link) { \
    OSThread* __next = thread->link.next;   \
    if (__next == NULL) {                   \
        (queue)->tail = NULL;               \
    }                                       \
    else {                                  \
        __next->link.prev = NULL;           \
    }                                       \
    (queue)->head = __next;                 \
}

/* Exactly named `IsSuspended` for assert */
#define IsSuspended(suspend)   (suspend > 0)

#define OS_THREAD_STACK_MAGIC   0xDEADBABE

/* Run queue */
static vu32             RunQueueBits;
static OSThreadQueue    RunQueue[OS_PRIORITY_MAX + 1];
static vBOOL            RunQueueHint;
static vs32             Reschedule;
 
/* Idle and default stuff */
static OSThread         IdleThread;
static OSThread         DefaultThread;
static OSContext        IdleContext;

/* Auto generated by linker. */
extern u8               _stack_addr[];
extern u8               _stack_end[];

/* Queue initialization */

void OSInitMutexQueue(OSMutexQueue* queue);
void OSInitThreadQueue(OSThreadQueue* queue);

/* Other small utilities */

static void OSClearStack(u8 value) {
    u32 *sp, *p;
    u32 pattern;

    u32 val32 = (u32)value;
    pattern = (val32 << 24) | (val32 << 16) | (val32 << 8) | val32;

    sp = (u32*)OSGetStackPointer();
    for (p = __OSCurrentThread->stackEnd + 1; p < sp; ++p) {
        *p = pattern;
    }
}

void OSSetCurrentThread(OSThread* thread);

/* Switch thread callback */

static void DefaultSwitchThreadCallback(OSThread* from, OSThread* to) {}
static OSSwitchThreadCallback SwitchThreadCallback = DefaultSwitchThreadCallback;

OSSwitchThreadCallback OSSetSwitchThreadCallback(OSSwitchThreadCallback callback) {
    OSSwitchThreadCallback prev;
    BOOL enabled;

    enabled = OSDisableInterrupts();
    prev = SwitchThreadCallback;

    SwitchThreadCallback = callback ? callback : DefaultSwitchThreadCallback;
    OSRestoreInterrupts(enabled);

    if (prev == DefaultSwitchThreadCallback) {
        return NULL;
    }

    return prev;
}

void __OSThreadInit() {
    OSThread* thread = &DefaultThread;
    OSPriority prio;

    // Setup default thread
    thread->state = OS_THREAD_STATE_RUNNING;
    thread->attr = OS_THREAD_ATTR_DETACH;
    thread->base = 16;
    thread->priority = 16;
    thread->suspend = 0;
    thread->value = (void*)-1;
    thread->mutex = 0;

    // Setup queues
    OSInitThreadQueue(&thread->queueJoin);
    OSInitMutexQueue(&thread->queueMutex);

    // Setup contexts
    __OSFPUContext = &thread->context;
    OSClearContext(&thread->context);
    OSSetCurrentContext(&thread->context);

    // Setup stack
    thread->stackBase = (u8*)&_stack_addr;
    thread->stackEnd = (u32*)&_stack_end;
    *thread->stackEnd = OS_THREAD_STACK_MAGIC;
    OSSetCurrentThread(thread);
    OSClearStack(0);

    // Setup run queues
    RunQueueBits = 0;
    RunQueueHint = FALSE;
    for (prio = 0; prio < OS_PRIORITY_MAX + 1; prio++) {
        OSInitThreadQueue(&RunQueue[prio]);
    }

    // Setup active thread queue
    OSInitThreadQueue(&__OSActiveThreadQueue);
    ENQUEUE_THREAD(thread, &__OSActiveThreadQueue, linkActive);

    // Setup idle context
    OSClearContext(&IdleContext);

    Reschedule = 0;
}

void OSInitThreadQueue(OSThreadQueue* queue) {
    queue->head = queue->tail = NULL;
}

void OSInitMutexQueue(OSMutexQueue* queue) {
    queue->head = queue->tail = NULL;
}

void OSSetCurrentThread(OSThread* thread) {
    SwitchThreadCallback(OSGetCurrentThread(), thread);
    __OSCurrentThread = thread;
}

OSThread* OSGetCurrentThread() {
    return __OSCurrentThread;
}

void __OSSwitchThread(OSThread* thread) {
    OSSetCurrentThread(thread);
    OSSetCurrentContext(&thread->context);
    OSLoadContext(&thread->context);
}

BOOL OSIsThreadSuspended(OSThread *thread) {
    return (IsSuspended(thread->suspend)) ? TRUE : FALSE;
}

BOOL OSIsThreadTerminated(OSThread* thread) {
    return thread->state == OS_THREAD_STATE_DEAD || thread->state == OS_THREAD_STATE_UNINITIALIZED ? TRUE : FALSE;
}

BOOL __OSIsThreadActive(OSThread* thread) {
    OSThread* active;
    if (thread->state == OS_THREAD_STATE_UNINITIALIZED) {
        return FALSE;
    }
    for (active = __OSActiveThreadQueue.head; active; active = active->linkActive.next) {
        if (thread == active) {
            return TRUE;
        }
    }
    return FALSE;
}

s32 OSDisableScheduler() {
    BOOL enabled;
    s32 count;
    enabled = OSDisableInterrupts();
    count = Reschedule++;
    OSRestoreInterrupts(enabled);
    return count;
}

s32 OSEnableScheduler() {
    BOOL enabled;
    s32 count;
    enabled = OSDisableInterrupts();
    count = Reschedule--;
    OSRestoreInterrupts(enabled);
    return count;
}

static void SetRun(OSThread *thread) {
    thread->queue = &RunQueue[thread->priority];
    ENQUEUE_THREAD(thread, thread->queue, link);
    RunQueueBits |= 1 << (OS_PRIORITY_MAX - thread->priority);
    RunQueueHint = TRUE;
}

static void UnsetRun(OSThread *thread) NO_INLINE {
    OSThreadQueue* queue;
    queue = thread->queue;
    DEQUEUE_THREAD(thread, queue, link);
    if (queue->head == NULL) {
        RunQueueBits &= ~(1 << (OS_PRIORITY_MAX - thread->priority));
    }
    thread->queue = NULL;
}

OSPriority __OSGetEffectivePriority(OSThread *thread) {
    OSPriority priority;
    OSMutex* mutex;
    OSThread* blocked;
    priority = thread->base;
    for (mutex = thread->queueMutex.head; mutex; mutex = mutex->link.next) {
        blocked = mutex->queue.head;
        if (blocked != NULL && blocked->priority < priority) {
            priority = blocked->priority;
        }
    }
    return priority;
}

OSThread* SetEffectivePriority(OSThread *thread, OSPriority priority) {
    switch (thread->state) {
        case OS_THREAD_STATE_READY: {
            UnsetRun(thread);
            thread->priority = priority;
            SetRun(thread);

            break;
        }
        case OS_THREAD_STATE_WAITING: {
            DEQUEUE_THREAD(thread, thread->queue, link);
            thread->priority = priority;

            ENQUEUE_THREAD_PRIO(thread, thread->queue, link);
            if (thread->mutex != NULL) {
                return thread->mutex->thread;
            }

            break;
        }
        case OS_THREAD_STATE_RUNNING: {
            RunQueueHint = TRUE;
            thread->priority = priority;

            break;
        }
    }

    return NULL;
}

static void UpdatePriority(OSThread* thread) {
    OSPriority priority;
    do {
        if (IsSuspended(thread->suspend)) {
            break;
        }
        priority = __OSGetEffectivePriority(thread);
        if (thread->priority == priority) {
            break;
        }
        thread = SetEffectivePriority(thread, priority);
    } while (thread);
}

void __OSPromoteThread(OSThread *thread, OSPriority priority) {
    do {
        if (IsSuspended(thread->suspend) || thread->priority <= priority) {
            break;
        }
        thread = SetEffectivePriority(thread, priority);
    } while (thread);
}

OSThread* SelectThread(BOOL yield) {
    OSContext* currentContext;

    OSThread *currentThread, *nextThread;

    OSPriority priority;
    OSThreadQueue* queue;

    if (Reschedule > 0) {
        return NULL;
    }

    currentContext = OSGetCurrentContext();
    currentThread = OSGetCurrentThread();

    if (currentContext != &currentThread->context) {
        return NULL;
    }

    if (currentThread) {
        if (currentThread->state == OS_THREAD_STATE_RUNNING) {
            if (yield == FALSE) {
                priority = __cntlzw(RunQueueBits);
                if (currentThread->priority <= priority)
                    return NULL;
            }
            currentThread->state = OS_THREAD_STATE_READY;
            SetRun(currentThread);
        }
        if (!(currentThread->context.state & OS_THREAD_STATE_RUNNING) && OSSaveContext(&currentThread->context) != 0) {
            return NULL;
        }
    }

    if (RunQueueBits == 0) {
        OSSetCurrentThread(NULL);
        OSSetCurrentContext(&IdleContext);
        do {
            OSEnableInterrupts();
            while (RunQueueBits == 0) {}
            OSDisableInterrupts();
        } while (RunQueueBits == 0);
        OSClearContext(&IdleContext);
    }

    RunQueueHint = 0;
    priority = __cntlzw(RunQueueBits);

    queue = &RunQueue[priority];
    nextThread = queue->head;

    DEQUEUE_HEAD(nextThread, queue, link);

    if (queue->head == NULL) {
        RunQueueBits &= ~(1 << (OS_PRIORITY_MAX - priority));
    }
    nextThread->queue = NULL;
    nextThread->state = OS_THREAD_STATE_RUNNING;
    __OSSwitchThread(nextThread);
    return nextThread;
}


void __OSReschedule() {
    if (RunQueueHint) {
        SelectThread(FALSE);
    }
}

void OSYieldThread() {
    BOOL enabled = OSDisableInterrupts();
    SelectThread(TRUE);
    OSRestoreInterrupts(enabled);
}

BOOL OSCreateThread(OSThread* thread, void* (*ThreadFunc)(void*), void* param, void* stack, u32 stackSize, OSPriority priority, u16 attr) {
    BOOL enabled;
    u32 sp;
    int i;

    if (priority < OS_PRIORITY_MIN || priority > OS_PRIORITY_MAX) {
        return FALSE;
    }

    thread->state = OS_THREAD_STATE_READY;
    thread->attr = attr & OS_THREAD_ATTR_DETACH;
    thread->priority = thread->base = priority;
    thread->suspend = 1;
    thread->value = (void*)-1;
    thread->mutex = NULL;
    OSInitThreadQueue(&thread->queueJoin);
    OSInitMutexQueue(&thread->queueMutex);

    sp = (u32)stack;
    sp = ROUNDDOWN(sp, 8);
    sp -= 8;

    ((u32*)sp)[0] = 0;
    ((u32*)sp)[1] = 0;

    OSInitContext(&thread->context, (u32)ThreadFunc, sp);

    thread->context.lr = (u32)OSExitThread;
    thread->context.gpr[3] = (u32)param;
    thread->stackBase = stack;
    thread->stackEnd = (u32*)((u32)stack - stackSize);
    *thread->stackEnd = OS_THREAD_STACK_MAGIC;
    thread->error = 0;
    for (i = 0; i < OS_THREAD_SPECIFIC_MAX; ++i) {
        thread->specific[i] = 0;
    }

    enabled = OSDisableInterrupts();
    if (__OSErrorTable[OS_EXCEPTION_FLOATING_POINT_EXCEPTION] != NULL) {
        thread->context.srr1 |= (MSR_FE0 | MSR_FE1);
        thread->context.state |= OS_THREAD_STATE_READY;
        thread->context.fpscr = OS_FPSCR_ENABLE | 4;

        for (i = 0; i < OS_PRIORITY_MAX + 1; ++i) {
            *(u64*)&thread->context.fpr[i] = (u64)0xFFFFFFFFFFFFFFFFLL;
            *(u64*)&thread->context.psf[i] = (u64)0xFFFFFFFFFFFFFFFFLL;
        }
    }

    ENQUEUE_THREAD(thread, &__OSActiveThreadQueue, linkActive);
    OSRestoreInterrupts(enabled);

    return TRUE;
}

void OSExitThread(void* val) {
    BOOL enabled;
    OSThread* currentThread;

    enabled = OSDisableInterrupts();
    currentThread = OSGetCurrentThread();
    OSClearContext(&currentThread->context);

    if (currentThread->attr & OS_THREAD_ATTR_DETACH) {
        DEQUEUE_THREAD(currentThread, &__OSActiveThreadQueue, linkActive);
        currentThread->state = OS_THREAD_STATE_UNINITIALIZED;
    }
    else {
        currentThread->state = OS_THREAD_STATE_DEAD;
        currentThread->value = val;
    }

    __OSUnlockAllMutex(currentThread);
    OSWakeupThread(&currentThread->queueJoin);

    RunQueueHint = TRUE;

    __OSReschedule();
    OSRestoreInterrupts(enabled);
}

void OSCancelThread(OSThread* thread) {
    BOOL enabled = OSDisableInterrupts();

    switch (thread->state) {
        case OS_THREAD_STATE_READY: {
            if (!IsSuspended(thread->suspend)) {
                UnsetRun(thread);
            }
            break;
        }
        case OS_THREAD_STATE_RUNNING: {
            RunQueueHint = TRUE;
            break;
        }
        case OS_THREAD_STATE_WAITING: {
            DEQUEUE_THREAD(thread, thread->queue, link);

            thread->queue = NULL;
            if (!IsSuspended(thread->suspend) && thread->mutex) {
                UpdatePriority(thread->mutex->thread);
            }
            break;
        }
        default: {
            OSRestoreInterrupts(enabled);
            return;
        }
    }

    OSClearContext(&thread->context);
    if (thread->attr & OS_THREAD_ATTR_DETACH) {
        DEQUEUE_THREAD(thread, &__OSActiveThreadQueue, linkActive);
        thread->state = OS_THREAD_STATE_UNINITIALIZED;
    } 
    else {
        thread->state = OS_THREAD_STATE_DEAD;
    }

    __OSUnlockAllMutex(thread);
    OSWakeupThread(&thread->queueJoin);
    __OSReschedule();

    OSRestoreInterrupts(enabled);
}

BOOL OSJoinThread(OSThread* thread, void* val) {
    BOOL enabled = OSDisableInterrupts();

    if (!(thread->attr & OS_THREAD_ATTR_DETACH) && thread->state != OS_THREAD_STATE_DEAD && thread->queueJoin.head == NULL) {
        OSSleepThread(&thread->queueJoin);
        if (!__OSIsThreadActive(thread)) {
            OSRestoreInterrupts(enabled);
            return FALSE;
        }
    }

    if (((volatile OSThread*)thread)->state == OS_THREAD_STATE_DEAD) {
        if (val != NULL) {
            *(u32*)val = (u32)thread->value;
        }
        DEQUEUE_THREAD(thread, &__OSActiveThreadQueue, linkActive);
        thread->state = OS_THREAD_STATE_UNINITIALIZED;
        OSRestoreInterrupts(enabled);
        return TRUE;
    }

    OSRestoreInterrupts(enabled);
    return FALSE;
}

void OSDetachThread(OSThread* thread) {
    BOOL enabled = OSDisableInterrupts();

    thread->attr |= OS_THREAD_ATTR_DETACH;
    if (thread->state == OS_THREAD_STATE_DEAD) {
        DEQUEUE_THREAD(thread, &__OSActiveThreadQueue, linkActive);
        thread->state = OS_THREAD_STATE_UNINITIALIZED;
    }

    OSWakeupThread(&thread->queueJoin);
    OSRestoreInterrupts(enabled);
}

s32 OSResumeThread(OSThread* thread) {
    BOOL enabled;
    s32  suspendCount;

    enabled = OSDisableInterrupts();

    suspendCount = thread->suspend--;

    if (thread->suspend < 0) {
        thread->suspend = 0;
    }
    else if (thread->suspend == 0) {
        switch (thread->state) {
            case OS_THREAD_STATE_READY: {
                thread->priority = __OSGetEffectivePriority(thread);
                SetRun(thread);
                break;
            }

            case OS_THREAD_STATE_WAITING: {
                DEQUEUE_THREAD(thread, thread->queue, link);

                thread->priority = __OSGetEffectivePriority(thread);
                ENQUEUE_THREAD_PRIO(thread, thread->queue, link);

                if (thread->mutex) {
                    UpdatePriority(thread->mutex->thread);
                }
                break;
            }
        }

        __OSReschedule();
    }

    OSRestoreInterrupts(enabled);
    return suspendCount;
}

s32 OSSuspendThread(OSThread* thread) {
    BOOL enabled;
    s32  suspendCount;

    enabled = OSDisableInterrupts();
    suspendCount = thread->suspend++;

    if (suspendCount == 0) {
        switch (thread->state) {
            case OS_THREAD_STATE_RUNNING: {
                RunQueueHint = TRUE;
                thread->state = OS_THREAD_STATE_READY;
                break;
            }

            case OS_THREAD_STATE_READY: {
                UnsetRun(thread);
                break;
            }

            case OS_THREAD_STATE_WAITING: {
                DEQUEUE_THREAD(thread, thread->queue, link);
                thread->priority = OS_PRIORITY_MAX + 1;
                ENQUEUE_THREAD(thread, thread->queue, link);

                if (thread->mutex) {
                    UpdatePriority(thread->mutex->thread);
                }
                break;
            }
        }

        __OSReschedule();
    }

    OSRestoreInterrupts(enabled);

    return suspendCount;
}

void OSSleepThread(OSThreadQueue* queue) {
    BOOL enabled;
    OSThread* currentThread;

    enabled = OSDisableInterrupts();
    currentThread = OSGetCurrentThread();

    currentThread->state = OS_THREAD_STATE_WAITING;
    currentThread->queue = queue;
    ENQUEUE_THREAD_PRIO(currentThread, queue, link);

    RunQueueHint = TRUE;

    __OSReschedule();
    OSRestoreInterrupts(enabled);
}

void OSWakeupThread(OSThreadQueue* queue) {
    BOOL enabled = OSDisableInterrupts();

    while (queue->head) {
        OSThread* thread = queue->head;
        DEQUEUE_HEAD(thread, queue, link);

        thread->state = OS_THREAD_STATE_READY;
        if (!IsSuspended(thread->suspend)) {
            SetRun(thread);
        }
    }
    __OSReschedule();
    OSRestoreInterrupts(enabled);
}

BOOL OSSetThreadPriority(OSThread* thread, OSPriority priority) {
    BOOL enabled;

    if (priority < OS_PRIORITY_MIN || priority > OS_PRIORITY_MAX) {
        return FALSE;
    }

    enabled = OSDisableInterrupts();

    if (thread->base != priority) {
        thread->base = priority;
        UpdatePriority(thread);
        __OSReschedule();
    }

    OSRestoreInterrupts(enabled);

    return TRUE;
}

OSPriority OSGetThreadPriority(OSThread* thread) {
    return thread->base;
}

BOOL CheckThreadQueue(OSThreadQueue* queue) {
    OSThread* thread;
    if (queue->head != NULL && queue->head->link.prev != NULL) {
        return FALSE;
    }
    if (queue->tail != NULL && queue->tail->link.next != NULL) {
        return FALSE;
    }
    for (thread = queue->head; thread != NULL; thread = thread->link.next) {
        if (thread->link.next != NULL && thread != thread->link.next->link.prev) {
            return FALSE;
        }
        if (thread->link.prev != NULL && thread != thread->link.prev->link.next) {
            return FALSE;
        }
    }
    return TRUE;
}

static BOOL IsMember(OSThreadQueue* queue, OSThread* thread) {
    OSThread* threadFind;
    for (threadFind = queue->head; threadFind; threadFind = threadFind->link.next) {
        if (thread == threadFind) {
            return TRUE;
        }
    }
    return FALSE;
}

#define OS_ACTIVE_THREAD_ASSERT(exp, line) {                            \
    if (!(exp)) {                                                       \
        OSReport("OSCheckActiveThreads: Failed "#exp" in %d\n", line);  \
        OSHalt("", line);                                               \
    }                                                                   \
}

s32 OSCheckActiveThreads() {
    OSThread* thread;
    OSPriority prio;

    s32 threadId = 0;

    BOOL enabled = OSDisableInterrupts();

    for (prio = OS_PRIORITY_MIN; prio <= OS_PRIORITY_MAX; prio++) {
        if (RunQueueBits & (1 << (OS_PRIORITY_MAX - prio))) {
            OS_ACTIVE_THREAD_ASSERT(RunQueue[prio].head != NULL && RunQueue[prio].tail != NULL, 1513);
        }
        else {
            OS_ACTIVE_THREAD_ASSERT(RunQueue[prio].head == NULL && RunQueue[prio].tail == NULL, 1518);
        }
        OS_ACTIVE_THREAD_ASSERT(CheckThreadQueue(&RunQueue[prio]), 1520);
    }

    OS_ACTIVE_THREAD_ASSERT(__OSActiveThreadQueue.head == NULL || __OSActiveThreadQueue.head->linkActive.prev == NULL, 1525);
    OS_ACTIVE_THREAD_ASSERT(__OSActiveThreadQueue.tail == NULL || __OSActiveThreadQueue.tail->linkActive.next == NULL, 1527);

    for (thread = __OSActiveThreadQueue.head; thread != NULL; thread = thread->linkActive.next) {
        threadId++;

        OS_ACTIVE_THREAD_ASSERT(thread->linkActive.next == NULL || thread == thread->linkActive.next->linkActive.prev, 1535);
        OS_ACTIVE_THREAD_ASSERT(thread->linkActive.prev == NULL || thread == thread->linkActive.prev->linkActive.next, 1537);

        OS_ACTIVE_THREAD_ASSERT(*(thread->stackEnd) == OS_THREAD_STACK_MAGIC, 1540);

        OS_ACTIVE_THREAD_ASSERT(OS_PRIORITY_MIN <= thread->priority && thread->priority <= OS_PRIORITY_MAX+1, 1543);
        OS_ACTIVE_THREAD_ASSERT(0 <= thread->suspend, 1544);
        OS_ACTIVE_THREAD_ASSERT(CheckThreadQueue(&thread->queueJoin), 1545);

        switch (thread->state) {
            case OS_THREAD_STATE_READY: {
                if (!IsSuspended(thread->suspend)) {
                    OS_ACTIVE_THREAD_ASSERT(thread->queue == &RunQueue[thread->priority], 1551);
                    OS_ACTIVE_THREAD_ASSERT(IsMember(&RunQueue[thread->priority], thread), 1552);
                    OS_ACTIVE_THREAD_ASSERT(thread->priority == __OSGetEffectivePriority(thread), 1553);
                }
                break;
            }
            case OS_THREAD_STATE_RUNNING: {
                OS_ACTIVE_THREAD_ASSERT(!IsSuspended(thread->suspend), 1557);
                OS_ACTIVE_THREAD_ASSERT(thread->queue == NULL, 1558);
                OS_ACTIVE_THREAD_ASSERT(thread->priority == __OSGetEffectivePriority(thread), 1559);
                break;
            }
            case OS_THREAD_STATE_WAITING: {
                OS_ACTIVE_THREAD_ASSERT(thread->queue != NULL, 1562);
                OS_ACTIVE_THREAD_ASSERT(CheckThreadQueue(thread->queue), 1563);
                OS_ACTIVE_THREAD_ASSERT(IsMember(thread->queue, thread), 1564);
                if (!IsSuspended(thread->suspend)) {
                    OS_ACTIVE_THREAD_ASSERT(thread->priority == __OSGetEffectivePriority(thread), 1567);
                }
                else {
                    OS_ACTIVE_THREAD_ASSERT(thread->priority == 32, 1571);
                }
                OS_ACTIVE_THREAD_ASSERT(!__OSCheckDeadLock(thread), 1573);
                break;
            }
            case OS_THREAD_STATE_DEAD: {
                OS_ACTIVE_THREAD_ASSERT(thread->queueMutex.head == NULL && thread->queueMutex.tail == NULL, 1577);
                break;
            }
            default: {
                OSReport("OSCheckActiveThreads: Failed. unkown thread state (%d) of thread %p\n", thread->state, thread);
                OSHalt("", 1583);
                break;
            }
        }

        OS_ACTIVE_THREAD_ASSERT(__OSCheckMutexes(thread), 1588);
    }

    OSRestoreInterrupts(enabled);
    return threadId;
}

void OSSetThreadSpecific(s32 index, void* ptr) {
    OSThread* thread = __OSCurrentThread;
    if (thread && 0 <= index && index < OS_THREAD_SPECIFIC_MAX) {
        thread->specific[index] = ptr;
    }
}

void* OSGetThreadSpecific(s32 index) {
    OSThread* thread = __OSCurrentThread;
    if (thread && 0 <= index && index < OS_THREAD_SPECIFIC_MAX) {
        return thread->specific[index];
    }
    return NULL;
}

static void SleepAlarmHandler(OSAlarm *alarm, OSContext *context) {
    OSResumeThread((OSThread*)OSGetAlarmUserData(alarm));
}

void OSSleepTicks(OSTime tick) {
    BOOL enabled;
    OSThread* current;
    OSAlarm sleepAlarm;

    enabled = OSDisableInterrupts();
    current = OSGetCurrentThread();

    if (current == NULL) {
        OSRestoreInterrupts(enabled);
        return;
    }

    OSCreateAlarm(&sleepAlarm);
    OSSetAlarmTag(&sleepAlarm, (u32)current);
    OSSetAlarmUserData(&sleepAlarm, (void*)current);
    OSSetAlarm(&sleepAlarm, tick, SleepAlarmHandler);

    OSSuspendThread(current);

    OSCancelAlarm(&sleepAlarm);

    OSRestoreInterrupts(enabled);
}

DECOMP_FORCE_ACTIVE(OSThread_c, IdleThread); // IdleThread is unused but linked anyway.
